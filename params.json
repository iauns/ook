{"name":"Ook","tagline":"dynamic bricking","body":"Introduction\r\n============\r\n\r\nThis is ook, a simple library for providing bricked versions of a dataset.\r\n\r\n`Bricking' is the term we use in some visualization subfields to refer\r\nto the process by which a large data set is carved into smaller pieces.\r\nThe major reason one does this is for memory usage reasons.  Typically,\r\na large data set exceeds the amount of physical memory available on\r\na machine.  One can load up a brick of the data, perform any needed\r\nprocessing, and then throw the brick away.  By iterating over this\r\nprocess, one can process the entire data set while only needing enough\r\nmemory for a single brick.\r\n\r\nOok essentially provides the illusion that your data set is already\r\nstored as bricks.\r\n\r\nWhat Ook is Not\r\n---------------\r\n\r\nOok *only* provides a contiguous, bricked view of a data set.  This\r\nmeans it may lack some features you desire.  You'll have to provide\r\nthem yourself.\r\n\r\nHere are some related ideas which are out of scope for Ook:\r\n\r\n - multiresolution.\r\n - file format abstraction.  Ook does not know about file formats.\r\n - memory handling.  Ook provides the tool; wield it how you will.\r\n - metadata handling\r\n - high-dimensional data.  Ook deals with 3D data only, though you can\r\n   hack lower dimensions with a ``1``-sized dimension.\r\n\r\nUsage\r\n=====\r\n\r\nOok is exported mostly as a set of function calls.  You'll need to\r\n``#include`` the header ``ook.h`` for the functions to be available.\r\nAll Ook functions begin with ``ook``, are always spelled with lowercase\r\ncharacters, and never contain underscores.\r\n\r\nThe important ones functions are:\r\n\r\n    bool ookinit(struct io);\r\n\r\n``ookinit`` is an initialization function for the library.  There is no\r\ncorresponding deinitialization function; just make sure all your files\r\nare closed.  The argument tells Ook which IO interface it should use.\r\nFor simple raw data, you can pass it ``StdCIO``.\r\n\r\n    struct ookfile;\r\n\r\n``ookfile`` is an opaque type which represents a file opened by Ook.\r\nNote that you may have a file open in your own code and opened a second\r\ntime through Ook.  With a \"header + data\" type of file format, you\r\nmight do this just to read the header and then open it again via Ook\r\nfor accessing the data.\r\n\r\nThere is a limit to the number of open ``struct ookfile``s a process\r\nmay have at any one time.  This limit is system-defined, but you may\r\nsafely assume it to be no less than 100.\r\n\r\n    enum OOKTYPE;\r\n\r\n``OOKTYPE`` is an enumeration which describes the underlying type of\r\nthe data.  The options are:\r\n\r\n    OOK_I8,OOK_U8, OOK_I16,OOK_U16, OOK_I32,OOK_U32, OOK_I64,OOK_U64,\r\n    OOK_FLOAT, OOK_DOUBLE\r\n\r\nThe data type of a file cannot be changed once it is opened.\r\n\r\n    struct ookfile* ookread(const char*, const uint64_t voxels[3],\r\n                            const size_t bricksize[3], const enum OOKTYPE,\r\n                            const size_t components);\r\n\r\n``ookread`` gives back a file used in basically all other Ook function\r\ncalls.  It only allows read access to a file.\r\n\r\nIn order, the arguments are: a filename to open, the full dimensions of\r\nthe file, the desired brick size, the underlying type of the data, and\r\nthe number of components in the data.\r\n\r\n    size_t ookbricks(const struct ookfile*);\r\n\r\n``ookbricks`` returns the total number of bricks in the file.  You\r\nmight use it in code like this, for example:\r\n\r\n    for(size_t i=0; i < ookbricks(f); ++i) {\r\n      /* process brick `i` */\r\n    }\r\n\r\nYou could technically calculate this yourself based on the volume and\r\nbrick size you gave Ook when you opened the file.\r\n\r\n    void ookmaxbricksize(const struct ookfile*, size_t[3]);\r\n\r\n``ookmaxbricksize`` simply returns the brick size you gave Ook when\r\nyou opened the file.  This is just for convenience; the intent is that\r\nyou can pass the ``struct ookfile`` around all over the place without\r\nalways duplicating its metadata.\r\n\r\n    void ookbricksize(struct ookfile*, const size_t id, size_t bsize[3]);\r\n\r\n``ookbricksize`` gives the brick size for a specific brick (``id``)\r\nin the data set.  This can be smaller than what is given by\r\n``ookmaxbricksize`` in the case that the bricking size does not evenly\r\ndivide the domain.  In that case, bricks on the edge of the domain may\r\nbe smaller than other bricks.\r\n\r\n    void ookbrick(struct ookfile*, size_t id, void* data);\r\n\r\n``ookbrick`` is probably the most important function of the library.\r\nIt reads the data for a given brick into the provided pointer.  No\r\nallocation is performed; Ook assumes ``data`` has enough memory to\r\nperform the copy.\r\n\r\nIf you get segfaults in ``ookbrick``, the most likely explanation is\r\nthat you are passing in an invalid pointer or a memory block which is\r\nnot large enough for the given brick.  Remember to calculate enough\r\nspace for multicomponent data and the width of each datum.\r\n\r\n    void ookdimensions(const struct ookfile*, uint64_t[3]);\r\n\r\nLike ``ookmaxbricksize``, this is a convenience function so that you\r\ndo not need to communicate file metadata all over your program.  It\r\nreturns the volume size information you gave to Ook when you opened the\r\nfile.\r\n\r\n    struct ookfile*\r\n    ookcreate(const char* filename, const uint64_t dims[3],\r\n              const size_t bsize[3], enum OOKTYPE, size_t components);\r\n\r\n``ookcreate`` is the \"writing\" analogy to ``ookread``.  The arguments\r\nare the same, but this gives write access to the underlying file\r\ninstead of read access.\r\n\r\nNote the given file is truncated!\r\n\r\nOok will not detect if you open the same file multiple times with\r\nany mixture of readers and writers.  The serialization of individual\r\nreaders/writers in this situation is undefined.\r\n\r\n    void ookwrite(struct ookfile*, const size_t id, const void*);\r\n\r\n``ookwrite`` is the opposite of ``ookbrick``: it writes the given data\r\nto the file at the correct positions for the brick ID.\r\n\r\n    int ookclose(struct ookfile*);\r\n\r\n``ookclose`` closes a file which was opened by ``ookread`` or\r\n``ookcreate``.  Any Ook calls which accept a ``struct ookfile`` give\r\nundefined results after an ``ookclose`` operation on the same file.\r\n\r\n*All Ook files must be closed*.\r\n\r\nNote that a close operation may be expensive.\r\n\r\nA common error is to ignore the return value of ``ookclose``.  Write\r\nerrors, in particular, are reported during the close.  Code which does\r\nnot check for errors on close should be assumed to write invalid output\r\nfiles.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}