<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of IO-INTERFACE</TITLE>
</HEAD><BODY>
<H1>IO-INTERFACE</H1>
Section: Ook Programmer's Manual (7)<BR>Updated: 2013-10-03<BR><A HREF="#index">Index</A>
<A HREF="../index.html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

io-interface - overview of how Ook's io-interfaces work
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<PRE>
<B>#include &lt;<A HREF="file:///usr/include/ook.h">ook.h</A>&gt;</B>

<B>enum OOKMODE { OOK_RDONLY, OOK_RDWR };</B>
<B>typedef void* (</B><I>opener</I><B>)(const char* </B><I>fn</I><B>,</B>
<B>                       const enum OOKMODE </B><I>mode</I><B>,</B>
<B>                       const void* </B><I>state</I><B>);</B>
<B>typedef int (</B><I>reader</I><B>)(void* </B><I>fd</I><B>, const off_t </B><I>offset</I><B>, </B>
<B>                     const size_t </B><I>len</I><B>, void* </B><I>buf</I><B>);</B>
<B>typedef int (</B><I>writer</I><B>)(void* </B><I>fd</I><B>, const off_t </B><I>offset</I><B>,</B>
<B>                     const size_t </B><I>len</I><B>, const void* </B><I>buf</I><B>);</B>
<B>typedef int (</B><I>closer</I><B>)(void*</B><I>fd</I><B>);</B>
<B>typedef void (</B><I>prealloc</I><B>)(void* </B><I>fd</I><B>, off_t </B><I>len</I><B>);</B>
<B>struct io {</B>
<B>  opener* open;</B>
<B>  reader* read;</B>
<B>  writer* write;</B>
<B>  closer* close;</B>
<B>  prealloc* preallocate;</B>
<B>  void* state;</B>
<B>};</B>
<B>extern struct io StdCIO;</B>
</PRE>

<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<P>

An Ook io-interface provides a contiguous binary stream of the
underlying data it allows access to.
<P>

All data access in Ook goes through the functions pointed to by the
<I>struct io</I>

members.  For simple raw data, these functions can be a thin forwarding layer
that just calls the underlying operating system APIs;
<I>StdCIO</I>

is exactly such a wrapper around C's
<I><A HREF="/ook/man/fopen.3.html">fopen</A></I>(3),

<I><A HREF="/ook/man/fread.3.html">fread</A></I>(3),

<I><A HREF="/ook/man/fclose.3.html">fclose</A></I>(3),

etc. calls.  However, the interface could abstract a more complex
data acquisition scheme, such as a set of image files, a database
connection, or a server application that accesses data over a socket.
<P>

The abstraction that an
<I>io-interface</I>

provides is simply that of a large, contiguously-stored data file.  If
the resource cannot provide this abstraction, it is
not a good fit for Ook.
<P>

Offsets and lengths in the
<I>io-interface</I>

always refer to
<B>bytes</B>,

not elements.
<P>

When the
<I>opener</I>

function is called, the final argument is the
<I>io-interface</I>'s

<B>state</B>

member.  Many interfaces do not require state, and should therefore ignore this
parameter.  Note that the
<B>state</B>

parameter is only given to the
<I>opener</I>

function; if the implementation requires state information during other
operations (e.g. in
<I>reader</I>),

then it should copy the information from the
<B>state</B>

variable into whatever memory it returns from the
<I>opener</I>

call.
<P>
<A NAME="lbAE">&nbsp;</A>
<H2>FUNCTIONS</H2>

<P>

An Ook interface is comprised of a series of function pointers---there
is no data exposed.  Some functions are labelled
<B>Optional</B>.

You may leave these functions NULL, at the cost of some functionality.  For
example, a missing
<B>reader</B>

implementation will cause the
<B><A HREF="/ook/man/ookread.3.html">ookread</A></B>(3)

call to fail.
<P>

The functions to implement are:
<DL COMPACT>
<DT><B>opener</B>.

<DD>
<B>Required</B>.

Provides access to the resource.  Implementations should allocate internal
resources here.  The function should verify that the resource exists during
this call.  the implementation
should verify that the given metadata matches what is available in the
resource, if possible.  The pointer returned is an opaque identifier;
Ook will pass it to the other
<I>io-interface</I>

functions (generally as the first argument), but otherwise does nothing to it.
Any internal state your interface needs should be contained in the memory
pointed to by the returned pointer.
<DT><B>reader</B>.

<DD>
<B>Optional</B>.

This is how data are accessed.  The first argument,
<I>fd</I>,

is (despite the name) not (necessarily) a file descriptor, but a pointer to
whatever your
<B>opener</B>

call returned.  You can assume this pointer is non-NULL.  The
<I>offset</I>

parameter gives the
<B>byte</B>

offset of the data to be read.
<I>len</I>

provides the number of
<B>bytes</B>

to read starting at
<I>offset</I>.

<I>buf</I>

is where the data should be copied to.  You should assume
<I>buf</I>

is non-NULL and that it is large enough to hold 
<I>len</I>

bytes of data.
<P>
<DT><B>writer</B>.

<DD>
<B>Optional</B>.

The
<B>writer</B>

function is the opposite of the
<B>reader</B>

function: it copies data from a user-supplied buffer into the resource provided
by the interface. Argument
<I>fd</I>

is a pointer to
whatever your
<B>opener</B>

call returned.  You can assume this pointer is non-NULL.  The
<I>offset</I>

parameter gives the
<B>byte</B>

offset of the data to be read.
<I>len</I>

provides the number of
<B>bytes</B>

to read starting at
<I>offset</I>.

<I>buf</I>

is where the data are copied from.  You should assume that
<I>buf</I>

is non-NULL and points to valid memory at least
<I>len</I>

bytes long.
<DT><B>closer</B>.

<DD>
<B>Required</B>.

The
<B>closer</B>

function indicates access to the resource is no longer required.
Implementations should use this opportunity to finish pending writes and
deallocate any internally-defined memory.  It is implementation-defined whether
or not the
<B>closer</B>

function actually flushes data through to permanent storage.
<DT><B>prealloc</B>.

<DD>
<B>Optional</B>.

The
<B>prealloc</B>

function indicates that a range of data values will be written to by this
process.  Some implementations may want to use this information to optimize
writes.  Implementations may omit implementations for
<B>prealloc</B>

with no loss in functionality; it is provided purely for optimization purposes.
<P>
</DL>
<A NAME="lbAF">&nbsp;</A>
<H2>RETURN VALUES and ERRORS</H2>

<P>

Each
<B>io-interface</B>

function has unique return value semantics.
<DL COMPACT>
<DT><B>opener</B>

<DD>
should return a pointer to internally-created state.  This pointer will be
passed to the other
<B>io-interface</B>

functions.  Should an error occur,
<B>opener</B>

functions should return NULL.
<DT><B>reader</B>

<DD>
should return 0 on success, and a non-zero error code on error.  Note that this
is
<B>not</B>

the number of bytes read!  In Ook, a read is either complete or it fails;
partial reads should return an error code.
<DT><B>writer</B>

<DD>
should return 0 on success, and a non-zero error code on error.  Note that this
is
<B>not</B>

the number of bytes written!  Partial writes should return an error code.
<DT><B>closer</B>

<DD>
should return 0 on success, and a non-zero error code on error.
<DT><B>prealloc</B>

<DD>
has no return value.
<P>
</DL>
<A NAME="lbAG">&nbsp;</A>
<H2>EXAMPLE</H2>

<P>

Below is the complete implementation of the
<I>StdCIO io-interface</I>.

This implementation assumes the file consists of a large, contiguous array of
bytes with no header or metadata information.  Thus, offsets translate directly
and the interface is essentially just a wrapper around the standard C library's
IO functions.
<P>
<PRE>
#include &lt;<A HREF="file:///usr/include/errno.h">errno.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/stdio.h">stdio.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/stdlib.h">stdlib.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/sys/types.h">sys/types.h</A>&gt;
#include &quot;io-interface.h&quot;

static void*
stdc_open(const char* fn, const enum OOKMODE mode, const void* state)
{
  (void) state;
  const char* access = &quot;rb&quot;;
  if(mode == OOK_RDWR) { access = &quot;wb&quot;; }
  FILE* fp = fopen(fn, access);

        if(NULL == fp) {
    errno = -EINVAL;
    return NULL;
        }
  return fp;
}

static int
stdc_read(void* fd, const off_t offset, const size_t len, void* buf)
{
  FILE* fp = (FILE*) fd;
  if(fseek(fp, offset, SEEK_SET) != 0) {
    return errno;
  }
  if(fread(buf, 1, len, fp) != len) {
    return errno;
  }
  return 0;
}

static int
stdc_write(void* fd, const off_t offset, const size_t len,
           const void* buf)
{
  FILE* fp = (FILE*) fd;
  if(fseek(fp, offset, SEEK_SET) != 0) {
    return errno;
  }
  if(fwrite(buf, 1, len, fp) != len) {
    return errno;
  }
  return 0;
}

static int
stdc_close(void* fd)
{
  FILE* fp = (FILE*) fd;
  if(fclose(fp) != 0) {
    return errno;
  }
  return 0;
}

struct io StdCIO = {
  .open = stdc_open,
  .read = stdc_read,
  .write = stdc_write,
  .close = stdc_close,
  .preallocate = NULL
};
</PRE>

<A NAME="lbAH">&nbsp;</A>
<H2>SEE ALSO</H2>

<P>
<B><A HREF="/ook/man/ookread.3.html">ookread</A></B>(3),

<B><A HREF="/ook/man/ookcreate.3.html">ookcreate</A></B>(3),

<B><A HREF="/ook/man/ookbrick.3.html">ookbrick</A></B>(3),

<B><A HREF="/ook/man/ookwrite.3.html">ookwrite</A></B>(3),

<B><A HREF="/ook/man/ookclose.3.html">ookclose</A></B>(3),

<B><A HREF="/ook/man/fopen.3.html">fopen</A></B>(3),

<B><A HREF="/ook/man/fread.3.html">fread</A></B>(3),

<B><A HREF="/ook/man/fclose.3.html">fclose</A></B>(3)

<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">FUNCTIONS</A><DD>
<DT><A HREF="#lbAF">RETURN VALUES and ERRORS</A><DD>
<DT><A HREF="#lbAG">EXAMPLE</A><DD>
<DT><A HREF="#lbAH">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="http://tfogal.github.io/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 03:08:27 GMT, October 08, 2013
</BODY>
</HTML>
